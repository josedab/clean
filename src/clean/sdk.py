"""Multi-Language SDK Support.

Provides language bindings and SDK generation for R, Julia, and JavaScript,
enabling data quality checks from any ML ecosystem.

Example (Python - generating SDKs):
    >>> from clean.sdk import SDKGenerator, generate_r_package, generate_js_client
    >>>
    >>> # Generate R package
    >>> generate_r_package(output_dir="./clean-r")
    >>>
    >>> # Generate JavaScript client
    >>> generate_js_client(output_dir="./clean-js")

Example (R usage - generated):
    # install.packages("clean")
    # library(clean)
    # result <- clean_analyze(df, label_column="target")
    # print(result$quality_score)

Example (JavaScript usage - generated):
    // const { CleanClient } = require('clean-data-quality');
    // const client = new CleanClient('http://localhost:8000');
    // const result = await client.analyze(data, { labelColumn: 'target' });
"""

from __future__ import annotations

import json
import logging
import os
import shutil
import subprocess
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any

logger = logging.getLogger(__name__)


class TargetLanguage(Enum):
    """Supported target languages for SDK generation."""

    R = "r"
    JULIA = "julia"
    JAVASCRIPT = "javascript"
    TYPESCRIPT = "typescript"


@dataclass
class SDKConfig:
    """Configuration for SDK generation."""

    package_name: str = "clean"
    version: str = "1.0.0"
    api_base_url: str = "http://localhost:8000"
    author: str = "Clean Team"
    description: str = "Data quality SDK for ML datasets"
    license: str = "MIT"
    include_docs: bool = True
    include_tests: bool = True


class SDKGenerator(ABC):
    """Base class for SDK generators."""

    def __init__(self, config: SDKConfig):
        self.config = config

    @property
    @abstractmethod
    def language(self) -> TargetLanguage:
        """Target language for this generator."""
        pass

    @abstractmethod
    def generate(self, output_dir: Path) -> None:
        """Generate the SDK in the specified directory."""
        pass

    def _ensure_dir(self, path: Path) -> None:
        """Ensure directory exists."""
        path.mkdir(parents=True, exist_ok=True)


class RSDKGenerator(SDKGenerator):
    """Generates R package for Clean."""

    @property
    def language(self) -> TargetLanguage:
        return TargetLanguage.R

    def generate(self, output_dir: Path) -> None:
        """Generate R package."""
        output_dir = Path(output_dir)
        self._ensure_dir(output_dir)

        # Create R package structure
        self._create_description(output_dir)
        self._create_namespace(output_dir)
        self._create_r_files(output_dir)
        if self.config.include_docs:
            self._create_man_pages(output_dir)
        if self.config.include_tests:
            self._create_tests(output_dir)

        logger.info("Generated R package at %s", output_dir)

    def _create_description(self, output_dir: Path) -> None:
        """Create DESCRIPTION file."""
        content = f"""Package: {self.config.package_name}
Title: Data Quality Analysis for ML Datasets
Version: {self.config.version}
Authors@R: person("{self.config.author}", role = c("aut", "cre"))
Description: {self.config.description}
    Provides functions to detect label errors, duplicates, outliers, and biases
    in machine learning datasets. Integrates with the Clean Python API.
License: {self.config.license}
Encoding: UTF-8
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.2.0
Imports:
    httr,
    jsonlite,
    R6
Suggests:
    testthat (>= 3.0.0)
Config/testthat/edition: 3
"""
        (output_dir / "DESCRIPTION").write_text(content)

    def _create_namespace(self, output_dir: Path) -> None:
        """Create NAMESPACE file."""
        content = """# Generated by roxygen2: do not edit by hand

export(CleanClient)
export(clean_analyze)
export(clean_detect_label_errors)
export(clean_detect_duplicates)
export(clean_detect_outliers)
export(clean_quality_score)
importFrom(httr,POST)
importFrom(httr,GET)
importFrom(httr,content)
importFrom(jsonlite,toJSON)
importFrom(jsonlite,fromJSON)
importFrom(R6,R6Class)
"""
        (output_dir / "NAMESPACE").write_text(content)

    def _create_r_files(self, output_dir: Path) -> None:
        """Create R source files."""
        r_dir = output_dir / "R"
        self._ensure_dir(r_dir)

        # Main client class
        client_content = f'''#\' Clean API Client
#\'
#\' R6 class for interacting with the Clean API.
#\'
#\' @export
CleanClient <- R6::R6Class("CleanClient",
  public = list(
    #\' @field base_url The base URL of the Clean API
    base_url = NULL,

    #\' @description Create a new CleanClient
    #\' @param base_url Base URL of the Clean API (default: {self.config.api_base_url})
    initialize = function(base_url = "{self.config.api_base_url}") {{
      self$base_url <- base_url
    }},

    #\' @description Analyze a dataset for quality issues
    #\' @param data A data.frame to analyze
    #\' @param label_column Name of the label column (optional)
    #\' @return A list containing quality analysis results
    analyze = function(data, label_column = NULL) {{
      body <- list(
        data = jsonlite::toJSON(data, dataframe = "rows"),
        label_column = label_column
      )
      resp <- httr::POST(
        paste0(self$base_url, "/analyze"),
        body = jsonlite::toJSON(body, auto_unbox = TRUE),
        httr::content_type_json()
      )
      jsonlite::fromJSON(httr::content(resp, "text", encoding = "UTF-8"))
    }},

    #\' @description Get quality score for a dataset
    #\' @param data A data.frame to analyze
    #\' @param label_column Name of the label column (optional)
    #\' @return Numeric quality score (0-100)
    quality_score = function(data, label_column = NULL) {{
      result <- self$analyze(data, label_column)
      result$quality_score
    }},

    #\' @description Detect label errors in a dataset
    #\' @param data A data.frame to analyze
    #\' @param label_column Name of the label column
    #\' @return A data.frame of detected label errors
    detect_label_errors = function(data, label_column) {{
      body <- list(
        data = jsonlite::toJSON(data, dataframe = "rows"),
        label_column = label_column
      )
      resp <- httr::POST(
        paste0(self$base_url, "/detect/label-errors"),
        body = jsonlite::toJSON(body, auto_unbox = TRUE),
        httr::content_type_json()
      )
      result <- jsonlite::fromJSON(httr::content(resp, "text", encoding = "UTF-8"))
      as.data.frame(result$errors)
    }},

    #\' @description Detect duplicates in a dataset
    #\' @param data A data.frame to analyze
    #\' @param similarity_threshold Minimum similarity for duplicates (default: 0.9)
    #\' @return A data.frame of detected duplicate pairs
    detect_duplicates = function(data, similarity_threshold = 0.9) {{
      body <- list(
        data = jsonlite::toJSON(data, dataframe = "rows"),
        similarity_threshold = similarity_threshold
      )
      resp <- httr::POST(
        paste0(self$base_url, "/detect/duplicates"),
        body = jsonlite::toJSON(body, auto_unbox = TRUE),
        httr::content_type_json()
      )
      result <- jsonlite::fromJSON(httr::content(resp, "text", encoding = "UTF-8"))
      as.data.frame(result$duplicates)
    }},

    #\' @description Detect outliers in a dataset
    #\' @param data A data.frame to analyze
    #\' @param method Outlier detection method (default: "isolation_forest")
    #\' @return A data.frame of detected outliers
    detect_outliers = function(data, method = "isolation_forest") {{
      body <- list(
        data = jsonlite::toJSON(data, dataframe = "rows"),
        method = method
      )
      resp <- httr::POST(
        paste0(self$base_url, "/detect/outliers"),
        body = jsonlite::toJSON(body, auto_unbox = TRUE),
        httr::content_type_json()
      )
      result <- jsonlite::fromJSON(httr::content(resp, "text", encoding = "UTF-8"))
      as.data.frame(result$outliers)
    }}
  )
)
'''
        (r_dir / "client.R").write_text(client_content)

        # Convenience functions
        functions_content = f'''#\' Analyze a dataset for data quality issues
#\'
#\' @param data A data.frame to analyze
#\' @param label_column Name of the label column (optional)
#\' @param base_url Base URL of the Clean API
#\' @return A list containing quality analysis results
#\' @export
#\' @examples
#\' \\dontrun{{
#\' result <- clean_analyze(iris, label_column = "Species")
#\' print(result$quality_score)
#\' }}
clean_analyze <- function(data, label_column = NULL, base_url = "{self.config.api_base_url}") {{
  client <- CleanClient$new(base_url)
  client$analyze(data, label_column)
}}

#\' Get quality score for a dataset
#\'
#\' @param data A data.frame to analyze
#\' @param label_column Name of the label column (optional)
#\' @param base_url Base URL of the Clean API
#\' @return Numeric quality score (0-100)
#\' @export
clean_quality_score <- function(data, label_column = NULL, base_url = "{self.config.api_base_url}") {{
  client <- CleanClient$new(base_url)
  client$quality_score(data, label_column)
}}

#\' Detect label errors in a dataset
#\'
#\' @param data A data.frame to analyze
#\' @param label_column Name of the label column
#\' @param base_url Base URL of the Clean API
#\' @return A data.frame of detected label errors
#\' @export
clean_detect_label_errors <- function(data, label_column, base_url = "{self.config.api_base_url}") {{
  client <- CleanClient$new(base_url)
  client$detect_label_errors(data, label_column)
}}

#\' Detect duplicates in a dataset
#\'
#\' @param data A data.frame to analyze
#\' @param similarity_threshold Minimum similarity threshold (default: 0.9)
#\' @param base_url Base URL of the Clean API
#\' @return A data.frame of duplicate pairs
#\' @export
clean_detect_duplicates <- function(data, similarity_threshold = 0.9, base_url = "{self.config.api_base_url}") {{
  client <- CleanClient$new(base_url)
  client$detect_duplicates(data, similarity_threshold)
}}

#\' Detect outliers in a dataset
#\'
#\' @param data A data.frame to analyze
#\' @param method Detection method (default: "isolation_forest")
#\' @param base_url Base URL of the Clean API
#\' @return A data.frame of detected outliers
#\' @export
clean_detect_outliers <- function(data, method = "isolation_forest", base_url = "{self.config.api_base_url}") {{
  client <- CleanClient$new(base_url)
  client$detect_outliers(data, method)
}}
'''
        (r_dir / "functions.R").write_text(functions_content)

    def _create_man_pages(self, output_dir: Path) -> None:
        """Create man pages (documentation)."""
        man_dir = output_dir / "man"
        self._ensure_dir(man_dir)

        # Basic man page for the package
        content = f"""% Generated by roxygen2: do not edit by hand
\\name{{{self.config.package_name}-package}}
\\alias{{{self.config.package_name}}}
\\alias{{{self.config.package_name}-package}}
\\title{{{self.config.description}}}
\\description{{
Clean is an AI-powered data quality platform for ML datasets.
Find and fix label errors, duplicates, outliers, and biases.
}}
\\author{{
{self.config.author}
}}
"""
        (man_dir / f"{self.config.package_name}-package.Rd").write_text(content)

    def _create_tests(self, output_dir: Path) -> None:
        """Create test files."""
        tests_dir = output_dir / "tests" / "testthat"
        self._ensure_dir(tests_dir)

        # Test helper
        helper_content = """# Test helper functions
library(testthat)
library(clean)
"""
        (tests_dir / "helper.R").write_text(helper_content)

        # Basic tests
        test_content = """test_that("CleanClient can be instantiated", {
  client <- CleanClient$new()
  expect_true(inherits(client, "CleanClient"))
  expect_equal(client$base_url, "http://localhost:8000")
})

test_that("Custom base URL works", {
  client <- CleanClient$new("http://custom:9000")
  expect_equal(client$base_url, "http://custom:9000")
})
"""
        (tests_dir / "test-client.R").write_text(test_content)


class JavaScriptSDKGenerator(SDKGenerator):
    """Generates JavaScript/TypeScript SDK for Clean."""

    @property
    def language(self) -> TargetLanguage:
        return TargetLanguage.JAVASCRIPT

    def generate(self, output_dir: Path) -> None:
        """Generate JavaScript SDK."""
        output_dir = Path(output_dir)
        self._ensure_dir(output_dir)

        # Create package structure
        self._create_package_json(output_dir)
        self._create_src_files(output_dir)
        self._create_types(output_dir)
        if self.config.include_docs:
            self._create_readme(output_dir)
        if self.config.include_tests:
            self._create_tests(output_dir)

        logger.info("Generated JavaScript SDK at %s", output_dir)

    def _create_package_json(self, output_dir: Path) -> None:
        """Create package.json."""
        package = {
            "name": f"{self.config.package_name}-data-quality",
            "version": self.config.version,
            "description": self.config.description,
            "main": "dist/index.js",
            "types": "dist/index.d.ts",
            "scripts": {
                "build": "tsc",
                "test": "jest",
                "lint": "eslint src/**/*.ts",
            },
            "keywords": ["data-quality", "machine-learning", "clean", "label-errors"],
            "author": self.config.author,
            "license": self.config.license,
            "dependencies": {
                "axios": "^1.6.0",
            },
            "devDependencies": {
                "typescript": "^5.0.0",
                "@types/node": "^20.0.0",
                "jest": "^29.0.0",
                "@types/jest": "^29.0.0",
                "ts-jest": "^29.0.0",
            },
        }

        (output_dir / "package.json").write_text(json.dumps(package, indent=2))

    def _create_src_files(self, output_dir: Path) -> None:
        """Create source files."""
        src_dir = output_dir / "src"
        self._ensure_dir(src_dir)

        # Main client
        client_content = f'''import axios, {{ AxiosInstance }} from 'axios';

export interface AnalysisResult {{
  qualityScore: number;
  nSamples: number;
  labelErrors: LabelError[];
  duplicates: DuplicatePair[];
  outliers: Outlier[];
  summary: string;
}}

export interface LabelError {{
  index: number;
  givenLabel: string | number;
  predictedLabel: string | number;
  confidence: number;
}}

export interface DuplicatePair {{
  index1: number;
  index2: number;
  similarity: number;
  isExact: boolean;
}}

export interface Outlier {{
  index: number;
  score: number;
  method: string;
}}

export interface AnalyzeOptions {{
  labelColumn?: string;
  detectLabelErrors?: boolean;
  detectDuplicates?: boolean;
  detectOutliers?: boolean;
}}

/**
 * Clean Data Quality Client
 *
 * @example
 * ```typescript
 * const client = new CleanClient('http://localhost:8000');
 * const result = await client.analyze(data, {{ labelColumn: 'target' }});
 * console.log(result.qualityScore);
 * ```
 */
export class CleanClient {{
  private client: AxiosInstance;

  /**
   * Create a new CleanClient
   * @param baseUrl - Base URL of the Clean API (default: {self.config.api_base_url})
   */
  constructor(baseUrl: string = '{self.config.api_base_url}') {{
    this.client = axios.create({{
      baseURL: baseUrl,
      headers: {{
        'Content-Type': 'application/json',
      }},
    }});
  }}

  /**
   * Analyze a dataset for quality issues
   * @param data - Array of objects representing the dataset
   * @param options - Analysis options
   * @returns Analysis result with quality score and detected issues
   */
  async analyze(
    data: Record<string, unknown>[],
    options: AnalyzeOptions = {{}}
  ): Promise<AnalysisResult> {{
    const response = await this.client.post('/analyze', {{
      data,
      label_column: options.labelColumn,
      detect_label_errors: options.detectLabelErrors ?? true,
      detect_duplicates: options.detectDuplicates ?? true,
      detect_outliers: options.detectOutliers ?? true,
    }});

    return this.transformResult(response.data);
  }}

  /**
   * Get quality score for a dataset
   * @param data - Array of objects representing the dataset
   * @param labelColumn - Name of the label column
   * @returns Quality score (0-100)
   */
  async qualityScore(
    data: Record<string, unknown>[],
    labelColumn?: string
  ): Promise<number> {{
    const result = await this.analyze(data, {{ labelColumn }});
    return result.qualityScore;
  }}

  /**
   * Detect label errors in a dataset
   * @param data - Array of objects representing the dataset
   * @param labelColumn - Name of the label column
   * @returns Array of detected label errors
   */
  async detectLabelErrors(
    data: Record<string, unknown>[],
    labelColumn: string
  ): Promise<LabelError[]> {{
    const response = await this.client.post('/detect/label-errors', {{
      data,
      label_column: labelColumn,
    }});

    return response.data.errors.map((e: any) => ({{
      index: e.index,
      givenLabel: e.given_label,
      predictedLabel: e.predicted_label,
      confidence: e.confidence,
    }}));
  }}

  /**
   * Detect duplicates in a dataset
   * @param data - Array of objects representing the dataset
   * @param similarityThreshold - Minimum similarity threshold (default: 0.9)
   * @returns Array of duplicate pairs
   */
  async detectDuplicates(
    data: Record<string, unknown>[],
    similarityThreshold: number = 0.9
  ): Promise<DuplicatePair[]> {{
    const response = await this.client.post('/detect/duplicates', {{
      data,
      similarity_threshold: similarityThreshold,
    }});

    return response.data.duplicates.map((d: any) => ({{
      index1: d.index1,
      index2: d.index2,
      similarity: d.similarity,
      isExact: d.is_exact,
    }}));
  }}

  /**
   * Detect outliers in a dataset
   * @param data - Array of objects representing the dataset
   * @param method - Detection method (default: 'isolation_forest')
   * @returns Array of detected outliers
   */
  async detectOutliers(
    data: Record<string, unknown>[],
    method: string = 'isolation_forest'
  ): Promise<Outlier[]> {{
    const response = await this.client.post('/detect/outliers', {{
      data,
      method,
    }});

    return response.data.outliers.map((o: any) => ({{
      index: o.index,
      score: o.score,
      method: o.method,
    }}));
  }}

  private transformResult(data: any): AnalysisResult {{
    return {{
      qualityScore: data.quality_score,
      nSamples: data.n_samples,
      labelErrors: (data.label_errors || []).map((e: any) => ({{
        index: e.index,
        givenLabel: e.given_label,
        predictedLabel: e.predicted_label,
        confidence: e.confidence,
      }})),
      duplicates: (data.duplicates || []).map((d: any) => ({{
        index1: d.index1,
        index2: d.index2,
        similarity: d.similarity,
        isExact: d.is_exact,
      }})),
      outliers: (data.outliers || []).map((o: any) => ({{
        index: o.index,
        score: o.score,
        method: o.method,
      }})),
      summary: data.summary,
    }};
  }}
}}

export default CleanClient;
'''
        (src_dir / "client.ts").write_text(client_content)

        # Index file
        index_content = """export { CleanClient, default } from './client';
export type {
  AnalysisResult,
  LabelError,
  DuplicatePair,
  Outlier,
  AnalyzeOptions,
} from './client';
"""
        (src_dir / "index.ts").write_text(index_content)

    def _create_types(self, output_dir: Path) -> None:
        """Create TypeScript configuration."""
        tsconfig = {
            "compilerOptions": {
                "target": "ES2020",
                "module": "commonjs",
                "lib": ["ES2020"],
                "declaration": True,
                "strict": True,
                "noImplicitAny": True,
                "strictNullChecks": True,
                "noImplicitThis": True,
                "alwaysStrict": True,
                "noUnusedLocals": False,
                "noUnusedParameters": False,
                "noImplicitReturns": True,
                "noFallthroughCasesInSwitch": False,
                "inlineSourceMap": True,
                "inlineSources": True,
                "experimentalDecorators": True,
                "strictPropertyInitialization": False,
                "outDir": "./dist",
                "rootDir": "./src",
            },
            "exclude": ["node_modules", "dist", "**/*.test.ts"],
        }

        (output_dir / "tsconfig.json").write_text(json.dumps(tsconfig, indent=2))

    def _create_readme(self, output_dir: Path) -> None:
        """Create README."""
        content = f"""# {self.config.package_name}-data-quality

{self.config.description}

## Installation

```bash
npm install {self.config.package_name}-data-quality
```

## Usage

```typescript
import {{ CleanClient }} from '{self.config.package_name}-data-quality';

// Create client
const client = new CleanClient('{self.config.api_base_url}');

// Analyze dataset
const data = [
  {{ feature1: 1.0, feature2: 'a', label: 'cat' }},
  {{ feature1: 2.0, feature2: 'b', label: 'dog' }},
  // ...
];

const result = await client.analyze(data, {{ labelColumn: 'label' }});
console.log(`Quality Score: ${{result.qualityScore}}`);
console.log(`Label Errors: ${{result.labelErrors.length}}`);

// Detect specific issues
const labelErrors = await client.detectLabelErrors(data, 'label');
const duplicates = await client.detectDuplicates(data);
const outliers = await client.detectOutliers(data);
```

## API Reference

### CleanClient

#### `analyze(data, options)`
Analyze a dataset for quality issues.

#### `qualityScore(data, labelColumn)`
Get quality score for a dataset (0-100).

#### `detectLabelErrors(data, labelColumn)`
Detect label errors in a dataset.

#### `detectDuplicates(data, similarityThreshold)`
Detect duplicates in a dataset.

#### `detectOutliers(data, method)`
Detect outliers in a dataset.

## License

{self.config.license}
"""
        (output_dir / "README.md").write_text(content)

    def _create_tests(self, output_dir: Path) -> None:
        """Create test files."""
        tests_dir = output_dir / "tests"
        self._ensure_dir(tests_dir)

        test_content = """import { CleanClient } from '../src/client';

describe('CleanClient', () => {
  it('should create client with default URL', () => {
    const client = new CleanClient();
    expect(client).toBeDefined();
  });

  it('should create client with custom URL', () => {
    const client = new CleanClient('http://custom:9000');
    expect(client).toBeDefined();
  });
});
"""
        (tests_dir / "client.test.ts").write_text(test_content)

        # Jest config
        jest_config = {
            "preset": "ts-jest",
            "testEnvironment": "node",
            "testMatch": ["**/tests/**/*.test.ts"],
        }
        (output_dir / "jest.config.json").write_text(json.dumps(jest_config, indent=2))


class JuliaSDKGenerator(SDKGenerator):
    """Generates Julia package for Clean."""

    @property
    def language(self) -> TargetLanguage:
        return TargetLanguage.JULIA

    def generate(self, output_dir: Path) -> None:
        """Generate Julia package."""
        output_dir = Path(output_dir)
        self._ensure_dir(output_dir)

        # Create package structure
        self._create_project_toml(output_dir)
        self._create_src_files(output_dir)
        if self.config.include_tests:
            self._create_tests(output_dir)
        if self.config.include_docs:
            self._create_readme(output_dir)

        logger.info("Generated Julia package at %s", output_dir)

    def _create_project_toml(self, output_dir: Path) -> None:
        """Create Project.toml."""
        content = f"""name = "Clean"
uuid = "12345678-1234-1234-1234-123456789abc"
version = "{self.config.version}"

[deps]
HTTP = "cd3eb016-35fb-5094-929b-558a96fad6f3"
JSON3 = "0f8b85d8-7281-11e9-16c2-39a750bddbf1"
DataFrames = "a93c6f00-e57d-5684-b7b6-d8193f3e46c0"

[compat]
HTTP = "1"
JSON3 = "1"
DataFrames = "1"
julia = "1.6"
"""
        (output_dir / "Project.toml").write_text(content)

    def _create_src_files(self, output_dir: Path) -> None:
        """Create source files."""
        src_dir = output_dir / "src"
        self._ensure_dir(src_dir)

        # Main module
        module_content = f'''module Clean

using HTTP
using JSON3
using DataFrames

export CleanClient, analyze, quality_score, detect_label_errors, detect_duplicates, detect_outliers

"""
    CleanClient

Client for interacting with the Clean API.

# Example
```julia
client = CleanClient("{self.config.api_base_url}")
result = analyze(client, df; label_column="target")
println(result.quality_score)
```
"""
mutable struct CleanClient
    base_url::String

    function CleanClient(base_url::String="{self.config.api_base_url}")
        new(base_url)
    end
end

"""
    AnalysisResult

Result of a quality analysis.
"""
struct AnalysisResult
    quality_score::Float64
    n_samples::Int
    label_errors::Vector{{Dict{{String,Any}}}}
    duplicates::Vector{{Dict{{String,Any}}}}
    outliers::Vector{{Dict{{String,Any}}}}
    summary::String
end

"""
    analyze(client::CleanClient, data::DataFrame; label_column=nothing)

Analyze a dataset for quality issues.

# Arguments
- `client`: CleanClient instance
- `data`: DataFrame to analyze
- `label_column`: Name of the label column (optional)

# Returns
AnalysisResult with quality score and detected issues
"""
function analyze(client::CleanClient, data::DataFrame; label_column=nothing)
    body = Dict(
        "data" => [Dict(pairs(row)) for row in eachrow(data)],
        "label_column" => label_column
    )

    response = HTTP.post(
        "$(client.base_url)/analyze",
        ["Content-Type" => "application/json"],
        JSON3.write(body)
    )

    result = JSON3.read(String(response.body))

    return AnalysisResult(
        result.quality_score,
        result.n_samples,
        get(result, :label_errors, []),
        get(result, :duplicates, []),
        get(result, :outliers, []),
        get(result, :summary, "")
    )
end

"""
    quality_score(client::CleanClient, data::DataFrame; label_column=nothing)

Get quality score for a dataset.

# Returns
Quality score between 0 and 100
"""
function quality_score(client::CleanClient, data::DataFrame; label_column=nothing)
    result = analyze(client, data; label_column=label_column)
    return result.quality_score
end

"""
    detect_label_errors(client::CleanClient, data::DataFrame, label_column::String)

Detect label errors in a dataset.

# Returns
DataFrame of detected label errors
"""
function detect_label_errors(client::CleanClient, data::DataFrame, label_column::String)
    body = Dict(
        "data" => [Dict(pairs(row)) for row in eachrow(data)],
        "label_column" => label_column
    )

    response = HTTP.post(
        "$(client.base_url)/detect/label-errors",
        ["Content-Type" => "application/json"],
        JSON3.write(body)
    )

    result = JSON3.read(String(response.body))
    errors = result.errors

    if isempty(errors)
        return DataFrame()
    end

    return DataFrame(errors)
end

"""
    detect_duplicates(client::CleanClient, data::DataFrame; similarity_threshold=0.9)

Detect duplicates in a dataset.

# Returns
DataFrame of duplicate pairs
"""
function detect_duplicates(client::CleanClient, data::DataFrame; similarity_threshold=0.9)
    body = Dict(
        "data" => [Dict(pairs(row)) for row in eachrow(data)],
        "similarity_threshold" => similarity_threshold
    )

    response = HTTP.post(
        "$(client.base_url)/detect/duplicates",
        ["Content-Type" => "application/json"],
        JSON3.write(body)
    )

    result = JSON3.read(String(response.body))
    duplicates = result.duplicates

    if isempty(duplicates)
        return DataFrame()
    end

    return DataFrame(duplicates)
end

"""
    detect_outliers(client::CleanClient, data::DataFrame; method="isolation_forest")

Detect outliers in a dataset.

# Returns
DataFrame of detected outliers
"""
function detect_outliers(client::CleanClient, data::DataFrame; method="isolation_forest")
    body = Dict(
        "data" => [Dict(pairs(row)) for row in eachrow(data)],
        "method" => method
    )

    response = HTTP.post(
        "$(client.base_url)/detect/outliers",
        ["Content-Type" => "application/json"],
        JSON3.write(body)
    )

    result = JSON3.read(String(response.body))
    outliers = result.outliers

    if isempty(outliers)
        return DataFrame()
    end

    return DataFrame(outliers)
end

end # module
'''
        (src_dir / "Clean.jl").write_text(module_content)

    def _create_tests(self, output_dir: Path) -> None:
        """Create test files."""
        test_dir = output_dir / "test"
        self._ensure_dir(test_dir)

        test_content = """using Clean
using Test

@testset "Clean.jl" begin
    @testset "CleanClient" begin
        client = CleanClient()
        @test client.base_url == "http://localhost:8000"

        client_custom = CleanClient("http://custom:9000")
        @test client_custom.base_url == "http://custom:9000"
    end
end
"""
        (test_dir / "runtests.jl").write_text(test_content)

    def _create_readme(self, output_dir: Path) -> None:
        """Create README."""
        content = f"""# Clean.jl

{self.config.description}

## Installation

```julia
using Pkg
Pkg.add(url="https://github.com/clean-data/Clean.jl")
```

## Usage

```julia
using Clean
using DataFrames

# Create client
client = CleanClient("{self.config.api_base_url}")

# Create sample data
df = DataFrame(
    feature1 = [1.0, 2.0, 3.0],
    feature2 = ["a", "b", "c"],
    label = ["cat", "dog", "cat"]
)

# Analyze dataset
result = analyze(client, df; label_column="label")
println("Quality Score: $(result.quality_score)")

# Get quality score directly
score = quality_score(client, df; label_column="label")

# Detect specific issues
label_errors = detect_label_errors(client, df, "label")
duplicates = detect_duplicates(client, df)
outliers = detect_outliers(client, df)
```

## License

{self.config.license}
"""
        (output_dir / "README.md").write_text(content)


def generate_r_package(
    output_dir: str | Path,
    config: SDKConfig | None = None,
) -> None:
    """Generate R package for Clean.

    Args:
        output_dir: Output directory for the package
        config: SDK configuration
    """
    config = config or SDKConfig()
    generator = RSDKGenerator(config)
    generator.generate(Path(output_dir))


def generate_js_client(
    output_dir: str | Path,
    config: SDKConfig | None = None,
) -> None:
    """Generate JavaScript/TypeScript client for Clean.

    Args:
        output_dir: Output directory for the package
        config: SDK configuration
    """
    config = config or SDKConfig()
    generator = JavaScriptSDKGenerator(config)
    generator.generate(Path(output_dir))


def generate_julia_package(
    output_dir: str | Path,
    config: SDKConfig | None = None,
) -> None:
    """Generate Julia package for Clean.

    Args:
        output_dir: Output directory for the package
        config: SDK configuration
    """
    config = config or SDKConfig()
    generator = JuliaSDKGenerator(config)
    generator.generate(Path(output_dir))


def generate_all_sdks(
    output_dir: str | Path,
    config: SDKConfig | None = None,
) -> dict[str, Path]:
    """Generate all language SDKs.

    Args:
        output_dir: Base output directory
        config: SDK configuration

    Returns:
        Dictionary mapping language to output path
    """
    output_dir = Path(output_dir)
    config = config or SDKConfig()

    paths = {}

    # Generate R
    r_path = output_dir / "r"
    generate_r_package(r_path, config)
    paths["r"] = r_path

    # Generate JavaScript
    js_path = output_dir / "javascript"
    generate_js_client(js_path, config)
    paths["javascript"] = js_path

    # Generate Julia
    julia_path = output_dir / "julia"
    generate_julia_package(julia_path, config)
    paths["julia"] = julia_path

    return paths
